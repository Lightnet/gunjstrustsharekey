/*
    Self contain Sandbox Gun Module:
    
    version: 2.0

    Created by: Lightnet

    Credit: amark ( https://github.com/amark/gun)

    License: MIT

    Gun Notes:
     * Work in progress
     * with sea.js and gun.js are buggy with auth checks.
    
    Information: To create share keys from User or Gun Graph. By creating trust map list and 
    key by default when encrypt function are call. Users are store in get('trust') map
    and you can change the key name in opt config to make it harder.

    User trust map store in child of root graph key. The trust store where graph path in user root.

    user.get(trust).get(publickey).get(pathnode).put('saltkey')
    
    Gun graph path is independent of created key root is base where graph call encryptput function
    but not the root graph node. It base on where the key root child graph location to generate 
    keys and trust map graph id to identify the keys and value. Simple example is tree node that
    each reference with ID that can't be same tree node. Each tree graph node has trust list if
    exist to share key who the owner to create it.

    Share Key config that support Gun and User that will detect type of root for User and Gun object.
    But can't be root graph when key are made will give errors.

    If get an error that object can't be used as text or string that root graph has to be json object.

    ```
    var object={// root id Object
        node:{// sub child 
            trust:[], //note is just example reference. `[]` it can't be used as graph. // sub child
            value:"key", //sub child
        }
    }
    // example
    let trust = get('trust');
    trust.get('publickey1').put('secret key');
    trust.get('publickey2').put('secret key');
    gun.get('object').put({trust:trust,value:"key"}); //json object
    ```
    This is json object format. Example how share key works. Name can be config.

    var object="key" //incorrect format
    //example
    gun.get('object').put('key') ///incorrect format, not json object

    //gun.get('foo').get('trust') //not here
    //user.get('trust') // since it root as well user own this graph
    gun.get('foo').get('something').encryptput('bar'); //create share key and create list
    gun.get('foo').get('something').get('trust') //it store users trust list on where encryptput graph.
    
    It the best to Share Key Genarete Salt Key by default to let know anyone to your keys.

    Random key used from:
     - SEA.random(16).toString();
     - Gun.text.random(16);
    
    User / Gun:
     - function grantkey (to allow owner user access to key graph value for other users. Check and create salt keys)
     - function revokekey (to owner revoke user access to key graph for user. Note it will break salt key if share with other users.)
      - Recreate new salt Share Key and reencrypt value.(This break other salt keys are shared.)
     - function encryptput put value (allow owner user to encrypt key value when creating and check salt key)
     - function decryptvalue return value (allow owner user to decrypt key value)
     - function decryptdata (to allow other user to decrypt key value/data from gun or sea but not self)
      - `let to = gun.user(public key)`
     
    User and Gun function for encrypt, decrypt and config key graph.
    sharekeyvalue:"value"; //default  //change to assign random secret key id
    sharekeytrust:"trust"; //default
    (gun/user).get('any').decryptvalue(cb,{sharekeyvalue:"value",sharekeytrust:"trust",sharekeydebug:false})
    (gun/user).get('any').encryptput(data,cb,{sharekeyvalue:"value",sharekeytrust:"trust",sharekeydebug:false})
    (gun/user).get('any').(grantkey|revokekey|decryptdata)(to,cb,{sharekeyvalue:"value",sharekeytrust:"trust",sharekeydebug:false})

    {sharekeybbase:true}  - This is for gun and not user graph.
    {sharekeydebug:false} - Debug key, value, and secret sea

    Notes:
     - Not tested large scale.
     - Not work on debug fails and checks. (work in progress)
     - Grant/Revoke self share key break share keys.
     - User encrypt json format will do fine. Gun encrypt root need to string and not json.
     - Need to fix which is user or gun root check for easy access when call function.
     - when user is store in root but when get from `let to = gun.user('key')` will not auto detect as user but gun object.
*/
(function() {
    var Gun = (typeof window !== "undefined")? window.Gun : require('gun/gun');
    
    Gun.on('opt', function(context) {
        //context.opt.sharekeytype="path";// path for user //This will auto check default for gun and user
        //context.opt.sharekeytype="graph"; //gun graph sea key will be convert to string and base (bug).
        context.opt.sharekeydebug = true;
        context.opt.sharekeyvalue = 'value';
        context.opt.sharekeytrust = 'trust';
        context.opt.sharekeybbase = true; //btoa, atob //base64 ecode and decode
        this.to.next(context);
    });
    
    /*
        //user...grantkey(to);
        let user = gun.user();
        let to = gun.user(publickey);
        user.get('profile').get('alias').grantkey(to);
    */
    function grantkey(to, cb, opt){
        // added new user to key to share current graph key
        console.log("`.grantkey` PROTOTYPE API MAY BE CHANGED OR RENAMED USE!");
        cb = cb || function(ctx) { return ctx };
        opt = opt || {};
        let gun = this, user = gun.back(-1).user(), pair = user._.sea, path = '';
        gun.back(function(at){ if(at.is){ return } path += (at.get||'') });
    
        opt.sharekeydebug = opt.sharekeydebug ||  gun._.root.opt.sharekeydebug;
        opt.sharekeyvalue = opt.sharekeyvalue ||  gun._.root.opt.sharekeyvalue;
        opt.sharekeytrust = opt.sharekeytrust ||  gun._.root.opt.sharekeytrust;
        opt.sharekeybbase = opt.sharekeybbase ||  gun._.root.opt.sharekeybbase;
        if (gun._.$ instanceof Gun.User){//check gun node is user object
            //console.log("User PASS");
            opt.sharekeytype = "path";
        }else{
            //console.log("Gun PASS");
            opt.sharekeytype = "graph";
        }
    
        (async function(){
            if(opt.sharekeydebug){
                console.log("opt.sharekeytype: ",opt.sharekeytype);
            }
            let enc, sec;
            if(opt.sharekeytype == "path"){
                sec = await user.get(opt.sharekeytrust).get(pair.pub).get(path).then();
                if(opt.sharekeydebug){
                    console.log("SECRET: ",sec);
                }
                sec = await SEA.decrypt(sec, pair);
                if(!sec){
                    //console.log("CREATE SALT KEY")
                    sec = SEA.random(16).toString();
                    if(opt.sharekeydebug){
                        console.log("CREATE SECRET: ",sec);
                    }
                    //sec = Gun.text.random(16);
                    enc = await SEA.encrypt(sec, pair);
                    user.get(opt.sharekeytrust).get(pair.pub).get(path).put(enc);
                }
            }
            if(opt.sharekeytype == "graph"){
                sec = await gun.get(opt.sharekeytrust).get(pair.pub).get(gun._.get).then();
                if(opt.sharekeydebug){
                    console.log("SECRET: ",sec);
                }
                if(sec !=null){
                    if(opt.sharekeybbase){
                        sec = window.atob(sec);
                    }
                    sec = JSON.parse(sec);
                }
                sec = await SEA.decrypt(sec, pair);
                if(!sec){
                    //console.log("CREATE SALT KEY")
                    sec = SEA.random(16).toString();
                    if(opt.sharekeydebug){
                        console.log("CREATE SECRET: ",sec);
                    }
                    //sec = Gun.text.random(16);
                    enc = await SEA.encrypt(sec, pair);
                    enc = JSON.stringify(enc);//need to be string bug root gun
                    if(opt.sharekeybbase){
                        enc = window.btoa(enc);
                    }
                    //console.log(enc);
                    gun.get(opt.sharekeytrust).get(pair.pub).get(gun._.get).put(enc);
                }
            }
    
            let pub = await to.get('pub').then();
            let epub = await to.get('epub').then();
            pub = await pub; epub = await epub;
            let dh = await SEA.secret(epub, pair);
            enc = await SEA.encrypt(sec, dh);
            if(opt.sharekeytype == "path"){
                if(opt.sharekeydebug){
                    console.log("TO sec: ",enc);
                }
                user.get(opt.sharekeytrust).get(pub).get(path).put(enc, cb);
            }
            if(opt.sharekeytype == "graph"){
                enc = JSON.stringify(enc);
                if(opt.sharekeybbase){
                    enc = window.btoa(enc);
                }
                //console.log(enc);
                if(opt.sharekeydebug){
                    console.log("TO sec: ",enc);
                }
                gun.get(opt.sharekeytrust).get(pub).get(gun._.get).put(enc, cb);
            }
        }());
        return gun;
    }
    /*
        //- Recreated new salt key to share.
        //- reencrypt key value on new salt
        //user...revokekey(to);
        let user = gun.user();
        let to = gun.user(publickey);
        user.get('profile').get('alias').revokekey(to);
    */
    function revokekey(to, cb, opt){
        // recreated new salt key share current graph key
        console.log("`.revokekey` PROTOTYPE API MAY BE CHANGED OR RENAMED USE!");
        cb = cb || function(ctx) { return ctx };
        opt = opt || {};
        let gun = this, user = gun.back(-1).user(), pair = user._.sea, path = '';
        gun.back(function(at){ if(at.is){ return } path += (at.get||'') });
        //console.log(path);
        if(!to){console.log("to User not set!");}
    
        opt.sharekeydebug = opt.sharekeydebug ||  gun._.root.opt.sharekeydebug;
        opt.sharekeyvalue = opt.sharekeyvalue ||  gun._.root.opt.sharekeyvalue;
        opt.sharekeytrust = opt.sharekeytrust ||  gun._.root.opt.sharekeytrust;
        opt.sharekeybbase = opt.sharekeybbase ||  gun._.root.opt.sharekeybbase;
        if (gun._.$ instanceof Gun.User){//check gun node is user object
            //console.log("User PASS");
            opt.sharekeytype = "path";
        }else{
            //console.log("Gun PASS");
            opt.sharekeytype = "graph";
        }
        (async function(){
            if(opt.sharekeydebug){
                console.log("opt.sharekeytype: ",opt.sharekeytype);
            }
            let alias = await to.get("alias").then();
            let pub;
            //console.log(alias);
            if(!alias){
                cb({err:'Error alias not found!'});
                return gun;
            }
            //GET Salt Key
            let enc, sec, key, value;
            if(opt.sharekeytype == "path"){
                sec = await user.get(opt.sharekeytrust).get(pair.pub).get(path).then();
                if(opt.sharekeydebug){
                    console.log("SECRET: ",sec);
                }
                sec = await SEA.decrypt(sec, pair);
                key = await gun.once().then();
                value = await SEA.decrypt(key, sec);
            }
            if(opt.sharekeytype == "graph"){
                sec = await gun.get(opt.sharekeytrust).get(pair.pub).get(gun._.get).then();
                if(opt.sharekeydebug){
                    console.log("SECRET: ",sec);
                }
                if(sec !=null){
                    if(opt.sharekeybbase){
                        sec = window.atob(sec);//decode
                    }
                    sec = JSON.parse(sec);
                }
                sec = await SEA.decrypt(sec, pair);
                key = await gun.get(opt.sharekeyvalue).once().then();
                if(opt.sharekeybbase){
                    key = window.atob(key);//decode
                }
                key = JSON.parse(key);
                value = await SEA.decrypt(key, sec);
            }
            if(opt.sharekeydebug){
                console.log("VALUE: ",value);
            }
            // Create New Salt Key
            sec = SEA.random(16).toString();
            //sec = Gun.text.random(16);
            enc = await SEA.encrypt(sec, pair);
            if(opt.sharekeytype == "path"){
                user.get(opt.sharekeytrust).get(pair.pub).get(path).put(enc);
                pub = await to.get('pub').then();//revoke user
                user.get(opt.sharekeytrust).once().map().once(async (data,mkey)=>{//trust users
                    let uname;
                    if(opt.sharekeydebug){
                        uname = await gun.back(-1).user(mkey).get('alias').then();
                    }
                    if(pair.pub != mkey){//check self user to be resalt
                        if(pub == mkey){ //check user to be revoke
                            //do nothing??? (revoke user)
                            if(opt.sharekeydebug){
                                console.log(uname, "FAIL");
                            }
                        }else{
                            let ckey = await user.get(opt.sharekeytrust).get(mkey).get(path).then();
                            if(opt.sharekeydebug){
                                console.log(uname, "PASS");
                            }
                            if(ckey != "null"){//Check if there user are revoke key if they are null should be ignore.
                                if(opt.sharekeydebug){
                                    console.log(uname, "CREATE NEW SALT SHARE KEY ");
                                }
                                let mto = gun.back(-1).user(mkey);
                                let mpub = await mto.get('pub').then();
                                let mepub = await mto.get('epub').then();
                                let dh = await SEA.secret(mepub, pair);
                                let menc = await SEA.encrypt(sec, dh);
                                //NEW SALT KEY
                                if(opt.sharekeydebug){
                                    console.log("NEW SHARE KEY: ",menc);
                                }
                                user.get(opt.sharekeytrust).get(mpub).get(path).put(menc);
                            }
                        }
                    }
                });
            }
            if(opt.sharekeytype == "graph"){
                enc = JSON.stringify(enc);//need to be string bug root gun
                enc = window.btoa(enc);
                gun.get(opt.sharekeytrust).get(pair.pub).get(gun._.get).put(enc);
                pub = await to.get('pub').then();
    
                gun.get(opt.sharekeytrust).map().once(async (data,mkey)=>{//trust users
                    let uname;
                    if(opt.sharekeydebug){
                        uname = await gun.back(-1).user(mkey).get('alias').then();
                    }
                    if(pair.pub != mkey){//check self user
                        if(pub == mkey){ //check user to be revoke
                            //do not here?(ban user)
                            if(opt.sharekeydebug){
                                console.log(uname, "FAIL");
                            }
                        }else{
                            let ckey = await gun.get(opt.sharekeytrust).get(key).get(gun._.get).then();
                            if(opt.sharekeydebug){
                                console.log(uname, "PASS");
                            }
                            if(ckey != "null"){//Check if there user are revoke key if they are null.
                                if(opt.sharekeydebug){
                                    console.log(uname, "NEW SHARE KEY!");
                                }
                                let mto = gun.back(-1).user(mkey);
                                let mpub = await mto.get('pub').then();
                                let mepub = await mto.get('epub').then();
                                let dh = await SEA.secret(mepub, pair);
                                //NEW SHARE KEY
                                let menc = await SEA.encrypt(sec, dh);
                                menc = JSON.stringify(menc);
                                if(opt.sharekeybbase){
                                    menc = window.btoa(menc);
                                }
                                if(opt.sharekeydebug){
                                    console.log("NEW SHARE KEY: ",menc);
                                }
                                gun.get(opt.sharekeytrust).get(mpub).get(gun._.get).put(menc);
                            }
                        }
                    }
                })
            }
            //encrypt Value
            let v = await SEA.encrypt(value, sec);
            if(opt.sharekeytype == "path"){
                gun.put(v, cb);
            }
            if(opt.sharekeytype == "graph"){
                v = JSON.stringify(v);
                if(opt.sharekeybbase){
                    v = window.btoa(v);
                }
                gun.get(opt.sharekeyvalue).put(v, cb);
            }
            // REMOVE SHARE KEY
            pub = await to.get('pub').then();
            if(opt.sharekeytype == "path"){
                user.get(opt.sharekeytrust).get(pub).get(path).put("null", cb);//REMOVE SECRET KEY
            }
            if(opt.sharekeytype == "graph"){
                gun.get(opt.sharekeytrust).get(pub).get(gun._.get).put("null", cb);//REMOVE SECRET KEY
            }
    
        }());
        return gun;
    }
    /*
        //user...encryptput(value);
        let user = gun.user();
        user.get('profile').get('alias').encryptput("name");
    */
    function encryptput(data, cb, opt){
        // encrypt key > put value
        console.log("`.encryptput` PROTOTYPE API MAY BE CHANGED OR RENAMED USE!");
        cb = cb || function(ctx) { return ctx };
        opt = opt || {};
        let gun = this, user = gun.back(-1).user(), pair = user._.sea, path = '';
        let rootgun = this;
        gun.back(function(at){ if(at.is){ return } path += (at.get||'') });

        opt.sharekeydebug = opt.sharekeydebug ||  gun._.root.opt.sharekeydebug;
        opt.sharekeyvalue = opt.sharekeyvalue ||  gun._.root.opt.sharekeyvalue;
        opt.sharekeytrust = opt.sharekeytrust ||  gun._.root.opt.sharekeytrust;
        opt.sharekeybbase = opt.sharekeybbase ||  gun._.root.opt.sharekeybbase;
        if (gun._.$ instanceof Gun.User){//check gun node is user object
            //console.log("User PASS");
            opt.sharekeytype = "path";
        }else{
            //console.log("Gun PASS");
            opt.sharekeytype = "graph";
        }
        //console.log(Gun.is(gun));//check if gun is object match

        (async function(){
            if(opt.sharekeydebug){
                console.log("opt.sharekeytype: ",opt.sharekeytype);
            }
            let enc, sec;
            if(opt.sharekeytype == "path"){
                sec = await user.get(opt.sharekeytrust).get(pair.pub).get(path).then();
                if(opt.sharekeydebug){
                    console.log("SECRET: ",sec);
                }
                sec = await SEA.decrypt(sec, pair);
                if(!sec){
                    sec = SEA.random(16).toString();
                    if(opt.sharekeydebug){
                        console.log("CREATE SECRET: ",sec);
                    }
                    //sec = Gun.text.random(16);
                    enc = await SEA.encrypt(sec, pair);
                    user.get(opt.sharekeytrust).get(pair.pub).get(path).put(enc);
                }
                enc = await SEA.encrypt(data, sec);
                gun.put(enc, cb);//PUT ENCRYPT DATA
            }
            
            if(opt.sharekeytype == "graph"){
                sec = await gun.get(opt.sharekeytrust).get(pair.pub).get(gun._.get).then();
                if(opt.sharekeydebug){
                    console.log("SECRET: ",sec);
                }
                if(sec !=null){
                    if(opt.sharekeybbase){
                        sec = window.atob(sec);
                    }
                    sec = JSON.parse(sec);
                    sec = await SEA.decrypt(sec, pair);
                }
                if(!sec){
                    sec = SEA.random(16).toString();
                    if(opt.sharekeydebug){
                        console.log("CREATE SECRET: ",sec);
                    }
                    enc = await SEA.encrypt(sec, pair);
                    enc = JSON.stringify(enc);//need to be string bug root gun
                    if(opt.sharekeybbase){
                        enc = window.btoa(enc);
                    }
                    if(opt.sharekeydebug){
                        console.log("SECRET ENC: ",enc);
                    }
                    gun.get(opt.sharekeytrust).get(pair.pub).get(gun._.get).put(enc);
                }
                if(opt.sharekeydebug){
                    console.log("DATA: ",data);
                }
                enc = await SEA.encrypt(data, sec);
                enc = JSON.stringify(enc);
                if(opt.sharekeybbase){
                    enc = window.btoa(enc);
                }
                //gun put need be child key value
                gun.get(opt.sharekeyvalue).put(enc, cb);//PUT ENCRYPT DATA
            }
        }());
        return gun;
    }
    /*
        user...decryptvalue(cb);
        let user = gun.user();
        user.get('profile').get('alias').decryptvalue(ack=>{
            //console.log(ack);
        });
    */
    function decryptvalue(cb,opt){
        //get decrypt key to return value
        console.log("`.decryptvalue` PROTOTYPE API MAY BE CHANGED OR RENAMED USE!");
        cb = cb || function(ctx) { return ctx };
        opt = opt || {};
        let gun = this, user = gun.back(-1).user(), pair = user._.sea, path = '';
    
        opt.sharekeydebug = opt.sharekeydebug ||  gun._.root.opt.sharekeydebug;
        opt.sharekeyvalue = opt.sharekeyvalue ||  gun._.root.opt.sharekeyvalue;
        opt.sharekeytrust = opt.sharekeytrust ||  gun._.root.opt.sharekeytrust;
        opt.sharekeybbase = opt.sharekeybbase ||  gun._.root.opt.sharekeybbase;
    
        gun.back(function(at){ if(at.is){ return } path += (at.get||'') });

        if (gun._.$ instanceof Gun.User){//check gun node is user object
            //console.log("User PASS");
            opt.sharekeytype = "path";
        }else{
            //console.log("Gun PASS");
            opt.sharekeytype = "graph";
        }
        
        (async function(){
            if(opt.sharekeydebug){
                console.log("opt.sharekeytype: ",opt.sharekeytype);
            }
            let sec, key;
            if(opt.sharekeytype == "path"){
                sec = await user.get(opt.sharekeytrust).get(pair.pub).get(path).then();
                if(opt.sharekeydebug){
                    console.log("SECRET: ",sec);
                }
                if(!sec){
                    cb(null);
                    return gun;
                }
                sec = await SEA.decrypt(sec, pair);
                key = await gun.then();
            }
            if(opt.sharekeytype == "graph"){
                sec = await gun.get(opt.sharekeytrust).get(pair.pub).get(gun._.get).then();
                if(opt.sharekeydebug){
                    console.log("SECRET: ",sec);
                }
                if(!sec){
                    cb(null);
                    return gun;
                }
                if(opt.sharekeybbase){
                    sec = window.atob(sec);
                }
                sec = JSON.parse(sec);
                sec = await SEA.decrypt(sec, pair);
                key = await gun.get(opt.sharekeyvalue).then();//default 'value'
                if(opt.sharekeydebug){
                    console.log("VALUE SEC: ",key);
                }
                if(key !=null){
                    if(opt.sharekeybbase){
                        key = window.atob(key);
                    }
                    key = JSON.parse(key);
                }
            }
            let mvalue = await SEA.decrypt(key, sec);
            if(opt.sharekeydebug){
                console.log("VALUE: ", mvalue);
            }
            cb(mvalue);
        }());
        return gun;
    }
    //working to decrypt data??
    /*
        //user...decryptdata(to,db);
        //gun...decryptdata(to,db);
        let user = gun.user();
        let to = gun.user(publickey);
        to.get("profile").get("alias").decryptdata(to,ack=>{
            console.log(ack);
        });
    */
    function decryptdata(to, cb, opt){
        // gun graph to decrypt key to return value
        console.log("`.decryptdata` PROTOTYPE API MAY BE DELETED OR CHANGED OR RENAMED USE!");
        cb = cb || function(ctx) { return ctx };
        opt = opt || {};
        let gun = this, user = gun.back(-1).user(), pair = user._.sea, path = '';
        //opt.sharekeytype = opt.sharekeytype || gun._.root.opt.sharekeytype;
        opt.sharekeydebug = opt.sharekeydebug ||  gun._.root.opt.sharekeydebug;
        opt.sharekeyvalue = opt.sharekeyvalue ||  gun._.root.opt.sharekeyvalue;
        opt.sharekeytrust = opt.sharekeytrust ||  gun._.root.opt.sharekeytrust;
        opt.sharekeybbase = opt.sharekeybbase ||  gun._.root.opt.sharekeybbase;
        if(!to){
            cb({err:"User not set!"});
            console.log("User graph net set!");
            return gun;
        }
        console.log(opt.sharekeydebug);

        if (gun._.$ instanceof Gun.User){//check gun node is user object
            //console.log("User PASS");
            opt.sharekeytype = opt.sharekeytype || "path";
        }else{
            //console.log("Gun PASS");
            opt.sharekeytype = opt.sharekeytype || "graph";
        }
    
        gun.back(function(at){ if(at.is){ return } path += (at.get||'') });
        (async function(){
            if(opt.sharekeydebug){
                console.log("opt.sharekeytype: ",opt.sharekeytype);
            }
            //KEY SALT
            let enc1
            if(opt.sharekeytype == "path"){
                enc1 = await to.get('trust').get(pair.pub).get(path).then();
                if(opt.sharekeydebug){
                    console.log("SECRET: ",enc1);
                }
            }
            if(opt.sharekeytype == "graph"){
                enc1 = await gun.get('trust').get(pair.pub).get(gun._.get).then();
                if(opt.sharekeydebug){
                    console.log("SECRET: ",enc1);
                }
                if(enc1 !=null){
                    if(enc1 == "null"){
                        console.log("Error Null || Denied!");
                        cb(null);
                        return gun;
                    }
                    if(opt.sharekeybbase){
                        enc1 = window.atob(enc1);
                    }
                    enc1 = JSON.parse(enc1);
                }
            }
            if(!enc1){
                console.log("Error Null || Denied!");
                cb(null);
                return gun;
            }
            let epub = await to.get('epub').then();
            //PAIR SHARE
            let mix = await SEA.secret(epub, pair);
            //KEY SHARE
            let key = await SEA.decrypt(enc1, mix);
            if(opt.sharekeydebug){
                console.log("key: ",key);
            }
            //VALUE
            let enc2 
            if(opt.sharekeytype == "path"){
                enc2 = await gun.then();
                if(opt.sharekeydebug){
                    console.log("VALUE sec: ",enc2);
                }
            }
            if(opt.sharekeytype == "graph"){
                enc2 = await gun.get(opt.sharekeyvalue).then();
                if(opt.sharekeydebug){
                    console.log("VALUE sec: ",enc2);
                }
                if(opt.sharekeybbase){
                    enc2 = window.atob(enc2);
                }
                enc2 = JSON.parse(enc2);
            }
            let dvalue = await SEA.decrypt(enc2, key);
            if(opt.sharekeydebug){
                console.log("VALUE: ",dvalue);
            }
            cb(dvalue);
        }());
        return gun;
    }
    //SETUP FUNCTION for GUN
    Gun.chain.grantkey = grantkey;
    Gun.chain.revokekey = revokekey;
    Gun.chain.encryptput = encryptput;
    Gun.chain.decryptvalue = decryptvalue;
    Gun.chain.decryptdata = decryptdata;
    
}());
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImd1bmpzdHJ1c3RzaGFyZWtleXYyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ3VuanN0cnVzdHNoYXJla2V5Lm1pbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXHJcbiAgICBTZWxmIGNvbnRhaW4gU2FuZGJveCBHdW4gTW9kdWxlOlxyXG4gICAgXHJcbiAgICB2ZXJzaW9uOiAyLjBcclxuXHJcbiAgICBDcmVhdGVkIGJ5OiBMaWdodG5ldFxyXG5cclxuICAgIENyZWRpdDogYW1hcmsgKCBodHRwczovL2dpdGh1Yi5jb20vYW1hcmsvZ3VuKVxyXG5cclxuICAgIExpY2Vuc2U6IE1JVFxyXG5cclxuICAgIEd1biBOb3RlczpcclxuICAgICAqIFdvcmsgaW4gcHJvZ3Jlc3NcclxuICAgICAqIHdpdGggc2VhLmpzIGFuZCBndW4uanMgYXJlIGJ1Z2d5IHdpdGggYXV0aCBjaGVja3MuXHJcbiAgICBcclxuICAgIEluZm9ybWF0aW9uOiBUbyBjcmVhdGUgc2hhcmUga2V5cyBmcm9tIFVzZXIgb3IgR3VuIEdyYXBoLiBCeSBjcmVhdGluZyB0cnVzdCBtYXAgbGlzdCBhbmQgXHJcbiAgICBrZXkgYnkgZGVmYXVsdCB3aGVuIGVuY3J5cHQgZnVuY3Rpb24gYXJlIGNhbGwuIFVzZXJzIGFyZSBzdG9yZSBpbiBnZXQoJ3RydXN0JykgbWFwXHJcbiAgICBhbmQgeW91IGNhbiBjaGFuZ2UgdGhlIGtleSBuYW1lIGluIG9wdCBjb25maWcgdG8gbWFrZSBpdCBoYXJkZXIuXHJcblxyXG4gICAgVXNlciB0cnVzdCBtYXAgc3RvcmUgaW4gY2hpbGQgb2Ygcm9vdCBncmFwaCBrZXkuIFRoZSB0cnVzdCBzdG9yZSB3aGVyZSBncmFwaCBwYXRoIGluIHVzZXIgcm9vdC5cclxuXHJcbiAgICB1c2VyLmdldCh0cnVzdCkuZ2V0KHB1YmxpY2tleSkuZ2V0KHBhdGhub2RlKS5wdXQoJ3NhbHRrZXknKVxyXG4gICAgXHJcbiAgICBHdW4gZ3JhcGggcGF0aCBpcyBpbmRlcGVuZGVudCBvZiBjcmVhdGVkIGtleSByb290IGlzIGJhc2Ugd2hlcmUgZ3JhcGggY2FsbCBlbmNyeXB0cHV0IGZ1bmN0aW9uXHJcbiAgICBidXQgbm90IHRoZSByb290IGdyYXBoIG5vZGUuIEl0IGJhc2Ugb24gd2hlcmUgdGhlIGtleSByb290IGNoaWxkIGdyYXBoIGxvY2F0aW9uIHRvIGdlbmVyYXRlIFxyXG4gICAga2V5cyBhbmQgdHJ1c3QgbWFwIGdyYXBoIGlkIHRvIGlkZW50aWZ5IHRoZSBrZXlzIGFuZCB2YWx1ZS4gU2ltcGxlIGV4YW1wbGUgaXMgdHJlZSBub2RlIHRoYXRcclxuICAgIGVhY2ggcmVmZXJlbmNlIHdpdGggSUQgdGhhdCBjYW4ndCBiZSBzYW1lIHRyZWUgbm9kZS4gRWFjaCB0cmVlIGdyYXBoIG5vZGUgaGFzIHRydXN0IGxpc3QgaWZcclxuICAgIGV4aXN0IHRvIHNoYXJlIGtleSB3aG8gdGhlIG93bmVyIHRvIGNyZWF0ZSBpdC5cclxuXHJcbiAgICBTaGFyZSBLZXkgY29uZmlnIHRoYXQgc3VwcG9ydCBHdW4gYW5kIFVzZXIgdGhhdCB3aWxsIGRldGVjdCB0eXBlIG9mIHJvb3QgZm9yIFVzZXIgYW5kIEd1biBvYmplY3QuXHJcbiAgICBCdXQgY2FuJ3QgYmUgcm9vdCBncmFwaCB3aGVuIGtleSBhcmUgbWFkZSB3aWxsIGdpdmUgZXJyb3JzLlxyXG5cclxuICAgIElmIGdldCBhbiBlcnJvciB0aGF0IG9iamVjdCBjYW4ndCBiZSB1c2VkIGFzIHRleHQgb3Igc3RyaW5nIHRoYXQgcm9vdCBncmFwaCBoYXMgdG8gYmUganNvbiBvYmplY3QuXHJcblxyXG4gICAgYGBgXHJcbiAgICB2YXIgb2JqZWN0PXsvLyByb290IGlkIE9iamVjdFxyXG4gICAgICAgIG5vZGU6ey8vIHN1YiBjaGlsZCBcclxuICAgICAgICAgICAgdHJ1c3Q6W10sIC8vbm90ZSBpcyBqdXN0IGV4YW1wbGUgcmVmZXJlbmNlLiBgW11gIGl0IGNhbid0IGJlIHVzZWQgYXMgZ3JhcGguIC8vIHN1YiBjaGlsZFxyXG4gICAgICAgICAgICB2YWx1ZTpcImtleVwiLCAvL3N1YiBjaGlsZFxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGV4YW1wbGVcclxuICAgIGxldCB0cnVzdCA9IGdldCgndHJ1c3QnKTtcclxuICAgIHRydXN0LmdldCgncHVibGlja2V5MScpLnB1dCgnc2VjcmV0IGtleScpO1xyXG4gICAgdHJ1c3QuZ2V0KCdwdWJsaWNrZXkyJykucHV0KCdzZWNyZXQga2V5Jyk7XHJcbiAgICBndW4uZ2V0KCdvYmplY3QnKS5wdXQoe3RydXN0OnRydXN0LHZhbHVlOlwia2V5XCJ9KTsgLy9qc29uIG9iamVjdFxyXG4gICAgYGBgXHJcbiAgICBUaGlzIGlzIGpzb24gb2JqZWN0IGZvcm1hdC4gRXhhbXBsZSBob3cgc2hhcmUga2V5IHdvcmtzLiBOYW1lIGNhbiBiZSBjb25maWcuXHJcblxyXG4gICAgdmFyIG9iamVjdD1cImtleVwiIC8vaW5jb3JyZWN0IGZvcm1hdFxyXG4gICAgLy9leGFtcGxlXHJcbiAgICBndW4uZ2V0KCdvYmplY3QnKS5wdXQoJ2tleScpIC8vL2luY29ycmVjdCBmb3JtYXQsIG5vdCBqc29uIG9iamVjdFxyXG5cclxuICAgIC8vZ3VuLmdldCgnZm9vJykuZ2V0KCd0cnVzdCcpIC8vbm90IGhlcmVcclxuICAgIC8vdXNlci5nZXQoJ3RydXN0JykgLy8gc2luY2UgaXQgcm9vdCBhcyB3ZWxsIHVzZXIgb3duIHRoaXMgZ3JhcGhcclxuICAgIGd1bi5nZXQoJ2ZvbycpLmdldCgnc29tZXRoaW5nJykuZW5jcnlwdHB1dCgnYmFyJyk7IC8vY3JlYXRlIHNoYXJlIGtleSBhbmQgY3JlYXRlIGxpc3RcclxuICAgIGd1bi5nZXQoJ2ZvbycpLmdldCgnc29tZXRoaW5nJykuZ2V0KCd0cnVzdCcpIC8vaXQgc3RvcmUgdXNlcnMgdHJ1c3QgbGlzdCBvbiB3aGVyZSBlbmNyeXB0cHV0IGdyYXBoLlxyXG4gICAgXHJcbiAgICBJdCB0aGUgYmVzdCB0byBTaGFyZSBLZXkgR2VuYXJldGUgU2FsdCBLZXkgYnkgZGVmYXVsdCB0byBsZXQga25vdyBhbnlvbmUgdG8geW91ciBrZXlzLlxyXG5cclxuICAgIFJhbmRvbSBrZXkgdXNlZCBmcm9tOlxyXG4gICAgIC0gU0VBLnJhbmRvbSgxNikudG9TdHJpbmcoKTtcclxuICAgICAtIEd1bi50ZXh0LnJhbmRvbSgxNik7XHJcbiAgICBcclxuICAgIFVzZXIgLyBHdW46XHJcbiAgICAgLSBmdW5jdGlvbiBncmFudGtleSAodG8gYWxsb3cgb3duZXIgdXNlciBhY2Nlc3MgdG8ga2V5IGdyYXBoIHZhbHVlIGZvciBvdGhlciB1c2Vycy4gQ2hlY2sgYW5kIGNyZWF0ZSBzYWx0IGtleXMpXHJcbiAgICAgLSBmdW5jdGlvbiByZXZva2VrZXkgKHRvIG93bmVyIHJldm9rZSB1c2VyIGFjY2VzcyB0byBrZXkgZ3JhcGggZm9yIHVzZXIuIE5vdGUgaXQgd2lsbCBicmVhayBzYWx0IGtleSBpZiBzaGFyZSB3aXRoIG90aGVyIHVzZXJzLilcclxuICAgICAgLSBSZWNyZWF0ZSBuZXcgc2FsdCBTaGFyZSBLZXkgYW5kIHJlZW5jcnlwdCB2YWx1ZS4oVGhpcyBicmVhayBvdGhlciBzYWx0IGtleXMgYXJlIHNoYXJlZC4pXHJcbiAgICAgLSBmdW5jdGlvbiBlbmNyeXB0cHV0IHB1dCB2YWx1ZSAoYWxsb3cgb3duZXIgdXNlciB0byBlbmNyeXB0IGtleSB2YWx1ZSB3aGVuIGNyZWF0aW5nIGFuZCBjaGVjayBzYWx0IGtleSlcclxuICAgICAtIGZ1bmN0aW9uIGRlY3J5cHR2YWx1ZSByZXR1cm4gdmFsdWUgKGFsbG93IG93bmVyIHVzZXIgdG8gZGVjcnlwdCBrZXkgdmFsdWUpXHJcbiAgICAgLSBmdW5jdGlvbiBkZWNyeXB0ZGF0YSAodG8gYWxsb3cgb3RoZXIgdXNlciB0byBkZWNyeXB0IGtleSB2YWx1ZS9kYXRhIGZyb20gZ3VuIG9yIHNlYSBidXQgbm90IHNlbGYpXHJcbiAgICAgIC0gYGxldCB0byA9IGd1bi51c2VyKHB1YmxpYyBrZXkpYFxyXG4gICAgIFxyXG4gICAgVXNlciBhbmQgR3VuIGZ1bmN0aW9uIGZvciBlbmNyeXB0LCBkZWNyeXB0IGFuZCBjb25maWcga2V5IGdyYXBoLlxyXG4gICAgc2hhcmVrZXl2YWx1ZTpcInZhbHVlXCI7IC8vZGVmYXVsdCAgLy9jaGFuZ2UgdG8gYXNzaWduIHJhbmRvbSBzZWNyZXQga2V5IGlkXHJcbiAgICBzaGFyZWtleXRydXN0OlwidHJ1c3RcIjsgLy9kZWZhdWx0XHJcbiAgICAoZ3VuL3VzZXIpLmdldCgnYW55JykuZGVjcnlwdHZhbHVlKGNiLHtzaGFyZWtleXZhbHVlOlwidmFsdWVcIixzaGFyZWtleXRydXN0OlwidHJ1c3RcIixzaGFyZWtleWRlYnVnOmZhbHNlfSlcclxuICAgIChndW4vdXNlcikuZ2V0KCdhbnknKS5lbmNyeXB0cHV0KGRhdGEsY2Ise3NoYXJla2V5dmFsdWU6XCJ2YWx1ZVwiLHNoYXJla2V5dHJ1c3Q6XCJ0cnVzdFwiLHNoYXJla2V5ZGVidWc6ZmFsc2V9KVxyXG4gICAgKGd1bi91c2VyKS5nZXQoJ2FueScpLihncmFudGtleXxyZXZva2VrZXl8ZGVjcnlwdGRhdGEpKHRvLGNiLHtzaGFyZWtleXZhbHVlOlwidmFsdWVcIixzaGFyZWtleXRydXN0OlwidHJ1c3RcIixzaGFyZWtleWRlYnVnOmZhbHNlfSlcclxuXHJcbiAgICB7c2hhcmVrZXliYmFzZTp0cnVlfSAgLSBUaGlzIGlzIGZvciBndW4gYW5kIG5vdCB1c2VyIGdyYXBoLlxyXG4gICAge3NoYXJla2V5ZGVidWc6ZmFsc2V9IC0gRGVidWcga2V5LCB2YWx1ZSwgYW5kIHNlY3JldCBzZWFcclxuXHJcbiAgICBOb3RlczpcclxuICAgICAtIE5vdCB0ZXN0ZWQgbGFyZ2Ugc2NhbGUuXHJcbiAgICAgLSBOb3Qgd29yayBvbiBkZWJ1ZyBmYWlscyBhbmQgY2hlY2tzLiAod29yayBpbiBwcm9ncmVzcylcclxuICAgICAtIEdyYW50L1Jldm9rZSBzZWxmIHNoYXJlIGtleSBicmVhayBzaGFyZSBrZXlzLlxyXG4gICAgIC0gVXNlciBlbmNyeXB0IGpzb24gZm9ybWF0IHdpbGwgZG8gZmluZS4gR3VuIGVuY3J5cHQgcm9vdCBuZWVkIHRvIHN0cmluZyBhbmQgbm90IGpzb24uXHJcbiAgICAgLSBOZWVkIHRvIGZpeCB3aGljaCBpcyB1c2VyIG9yIGd1biByb290IGNoZWNrIGZvciBlYXN5IGFjY2VzcyB3aGVuIGNhbGwgZnVuY3Rpb24uXHJcbiAgICAgLSB3aGVuIHVzZXIgaXMgc3RvcmUgaW4gcm9vdCBidXQgd2hlbiBnZXQgZnJvbSBgbGV0IHRvID0gZ3VuLnVzZXIoJ2tleScpYCB3aWxsIG5vdCBhdXRvIGRldGVjdCBhcyB1c2VyIGJ1dCBndW4gb2JqZWN0LlxyXG4qL1xyXG4oZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgR3VuID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpPyB3aW5kb3cuR3VuIDogcmVxdWlyZSgnZ3VuL2d1bicpO1xyXG4gICAgXHJcbiAgICBHdW4ub24oJ29wdCcsIGZ1bmN0aW9uKGNvbnRleHQpIHtcclxuICAgICAgICAvL2NvbnRleHQub3B0LnNoYXJla2V5dHlwZT1cInBhdGhcIjsvLyBwYXRoIGZvciB1c2VyIC8vVGhpcyB3aWxsIGF1dG8gY2hlY2sgZGVmYXVsdCBmb3IgZ3VuIGFuZCB1c2VyXHJcbiAgICAgICAgLy9jb250ZXh0Lm9wdC5zaGFyZWtleXR5cGU9XCJncmFwaFwiOyAvL2d1biBncmFwaCBzZWEga2V5IHdpbGwgYmUgY29udmVydCB0byBzdHJpbmcgYW5kIGJhc2UgKGJ1ZykuXHJcbiAgICAgICAgY29udGV4dC5vcHQuc2hhcmVrZXlkZWJ1ZyA9IHRydWU7XHJcbiAgICAgICAgY29udGV4dC5vcHQuc2hhcmVrZXl2YWx1ZSA9ICd2YWx1ZSc7XHJcbiAgICAgICAgY29udGV4dC5vcHQuc2hhcmVrZXl0cnVzdCA9ICd0cnVzdCc7XHJcbiAgICAgICAgY29udGV4dC5vcHQuc2hhcmVrZXliYmFzZSA9IHRydWU7IC8vYnRvYSwgYXRvYiAvL2Jhc2U2NCBlY29kZSBhbmQgZGVjb2RlXHJcbiAgICAgICAgdGhpcy50by5uZXh0KGNvbnRleHQpO1xyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8qXHJcbiAgICAgICAgLy91c2VyLi4uZ3JhbnRrZXkodG8pO1xyXG4gICAgICAgIGxldCB1c2VyID0gZ3VuLnVzZXIoKTtcclxuICAgICAgICBsZXQgdG8gPSBndW4udXNlcihwdWJsaWNrZXkpO1xyXG4gICAgICAgIHVzZXIuZ2V0KCdwcm9maWxlJykuZ2V0KCdhbGlhcycpLmdyYW50a2V5KHRvKTtcclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBncmFudGtleSh0bywgY2IsIG9wdCl7XHJcbiAgICAgICAgLy8gYWRkZWQgbmV3IHVzZXIgdG8ga2V5IHRvIHNoYXJlIGN1cnJlbnQgZ3JhcGgga2V5XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJgLmdyYW50a2V5YCBQUk9UT1RZUEUgQVBJIE1BWSBCRSBDSEFOR0VEIE9SIFJFTkFNRUQgVVNFIVwiKTtcclxuICAgICAgICBjYiA9IGNiIHx8IGZ1bmN0aW9uKGN0eCkgeyByZXR1cm4gY3R4IH07XHJcbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xyXG4gICAgICAgIGxldCBndW4gPSB0aGlzLCB1c2VyID0gZ3VuLmJhY2soLTEpLnVzZXIoKSwgcGFpciA9IHVzZXIuXy5zZWEsIHBhdGggPSAnJztcclxuICAgICAgICBndW4uYmFjayhmdW5jdGlvbihhdCl7IGlmKGF0LmlzKXsgcmV0dXJuIH0gcGF0aCArPSAoYXQuZ2V0fHwnJykgfSk7XHJcbiAgICBcclxuICAgICAgICBvcHQuc2hhcmVrZXlkZWJ1ZyA9IG9wdC5zaGFyZWtleWRlYnVnIHx8ICBndW4uXy5yb290Lm9wdC5zaGFyZWtleWRlYnVnO1xyXG4gICAgICAgIG9wdC5zaGFyZWtleXZhbHVlID0gb3B0LnNoYXJla2V5dmFsdWUgfHwgIGd1bi5fLnJvb3Qub3B0LnNoYXJla2V5dmFsdWU7XHJcbiAgICAgICAgb3B0LnNoYXJla2V5dHJ1c3QgPSBvcHQuc2hhcmVrZXl0cnVzdCB8fCAgZ3VuLl8ucm9vdC5vcHQuc2hhcmVrZXl0cnVzdDtcclxuICAgICAgICBvcHQuc2hhcmVrZXliYmFzZSA9IG9wdC5zaGFyZWtleWJiYXNlIHx8ICBndW4uXy5yb290Lm9wdC5zaGFyZWtleWJiYXNlO1xyXG4gICAgICAgIGlmIChndW4uXy4kIGluc3RhbmNlb2YgR3VuLlVzZXIpey8vY2hlY2sgZ3VuIG5vZGUgaXMgdXNlciBvYmplY3RcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlVzZXIgUEFTU1wiKTtcclxuICAgICAgICAgICAgb3B0LnNoYXJla2V5dHlwZSA9IFwicGF0aFwiO1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiR3VuIFBBU1NcIik7XHJcbiAgICAgICAgICAgIG9wdC5zaGFyZWtleXR5cGUgPSBcImdyYXBoXCI7XHJcbiAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgKGFzeW5jIGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIGlmKG9wdC5zaGFyZWtleWRlYnVnKXtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwib3B0LnNoYXJla2V5dHlwZTogXCIsb3B0LnNoYXJla2V5dHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGVuYywgc2VjO1xyXG4gICAgICAgICAgICBpZihvcHQuc2hhcmVrZXl0eXBlID09IFwicGF0aFwiKXtcclxuICAgICAgICAgICAgICAgIHNlYyA9IGF3YWl0IHVzZXIuZ2V0KG9wdC5zaGFyZWtleXRydXN0KS5nZXQocGFpci5wdWIpLmdldChwYXRoKS50aGVuKCk7XHJcbiAgICAgICAgICAgICAgICBpZihvcHQuc2hhcmVrZXlkZWJ1Zyl7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJTRUNSRVQ6IFwiLHNlYyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzZWMgPSBhd2FpdCBTRUEuZGVjcnlwdChzZWMsIHBhaXIpO1xyXG4gICAgICAgICAgICAgICAgaWYoIXNlYyl7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkNSRUFURSBTQUxUIEtFWVwiKVxyXG4gICAgICAgICAgICAgICAgICAgIHNlYyA9IFNFQS5yYW5kb20oMTYpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYob3B0LnNoYXJla2V5ZGVidWcpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkNSRUFURSBTRUNSRVQ6IFwiLHNlYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vc2VjID0gR3VuLnRleHQucmFuZG9tKDE2KTtcclxuICAgICAgICAgICAgICAgICAgICBlbmMgPSBhd2FpdCBTRUEuZW5jcnlwdChzZWMsIHBhaXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHVzZXIuZ2V0KG9wdC5zaGFyZWtleXRydXN0KS5nZXQocGFpci5wdWIpLmdldChwYXRoKS5wdXQoZW5jKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihvcHQuc2hhcmVrZXl0eXBlID09IFwiZ3JhcGhcIil7XHJcbiAgICAgICAgICAgICAgICBzZWMgPSBhd2FpdCBndW4uZ2V0KG9wdC5zaGFyZWtleXRydXN0KS5nZXQocGFpci5wdWIpLmdldChndW4uXy5nZXQpLnRoZW4oKTtcclxuICAgICAgICAgICAgICAgIGlmKG9wdC5zaGFyZWtleWRlYnVnKXtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlNFQ1JFVDogXCIsc2VjKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmKHNlYyAhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKG9wdC5zaGFyZWtleWJiYXNlKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VjID0gd2luZG93LmF0b2Ioc2VjKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc2VjID0gSlNPTi5wYXJzZShzZWMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2VjID0gYXdhaXQgU0VBLmRlY3J5cHQoc2VjLCBwYWlyKTtcclxuICAgICAgICAgICAgICAgIGlmKCFzZWMpe1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJDUkVBVEUgU0FMVCBLRVlcIilcclxuICAgICAgICAgICAgICAgICAgICBzZWMgPSBTRUEucmFuZG9tKDE2KS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKG9wdC5zaGFyZWtleWRlYnVnKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJDUkVBVEUgU0VDUkVUOiBcIixzZWMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvL3NlYyA9IEd1bi50ZXh0LnJhbmRvbSgxNik7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5jID0gYXdhaXQgU0VBLmVuY3J5cHQoc2VjLCBwYWlyKTtcclxuICAgICAgICAgICAgICAgICAgICBlbmMgPSBKU09OLnN0cmluZ2lmeShlbmMpOy8vbmVlZCB0byBiZSBzdHJpbmcgYnVnIHJvb3QgZ3VuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYob3B0LnNoYXJla2V5YmJhc2Upe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmMgPSB3aW5kb3cuYnRvYShlbmMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKGVuYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3VuLmdldChvcHQuc2hhcmVrZXl0cnVzdCkuZ2V0KHBhaXIucHViKS5nZXQoZ3VuLl8uZ2V0KS5wdXQoZW5jKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgICAgIGxldCBwdWIgPSBhd2FpdCB0by5nZXQoJ3B1YicpLnRoZW4oKTtcclxuICAgICAgICAgICAgbGV0IGVwdWIgPSBhd2FpdCB0by5nZXQoJ2VwdWInKS50aGVuKCk7XHJcbiAgICAgICAgICAgIHB1YiA9IGF3YWl0IHB1YjsgZXB1YiA9IGF3YWl0IGVwdWI7XHJcbiAgICAgICAgICAgIGxldCBkaCA9IGF3YWl0IFNFQS5zZWNyZXQoZXB1YiwgcGFpcik7XHJcbiAgICAgICAgICAgIGVuYyA9IGF3YWl0IFNFQS5lbmNyeXB0KHNlYywgZGgpO1xyXG4gICAgICAgICAgICBpZihvcHQuc2hhcmVrZXl0eXBlID09IFwicGF0aFwiKXtcclxuICAgICAgICAgICAgICAgIGlmKG9wdC5zaGFyZWtleWRlYnVnKXtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlRPIHNlYzogXCIsZW5jKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHVzZXIuZ2V0KG9wdC5zaGFyZWtleXRydXN0KS5nZXQocHViKS5nZXQocGF0aCkucHV0KGVuYywgY2IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKG9wdC5zaGFyZWtleXR5cGUgPT0gXCJncmFwaFwiKXtcclxuICAgICAgICAgICAgICAgIGVuYyA9IEpTT04uc3RyaW5naWZ5KGVuYyk7XHJcbiAgICAgICAgICAgICAgICBpZihvcHQuc2hhcmVrZXliYmFzZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5jID0gd2luZG93LmJ0b2EoZW5jKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coZW5jKTtcclxuICAgICAgICAgICAgICAgIGlmKG9wdC5zaGFyZWtleWRlYnVnKXtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlRPIHNlYzogXCIsZW5jKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGd1bi5nZXQob3B0LnNoYXJla2V5dHJ1c3QpLmdldChwdWIpLmdldChndW4uXy5nZXQpLnB1dChlbmMsIGNiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgcmV0dXJuIGd1bjtcclxuICAgIH1cclxuICAgIC8qXHJcbiAgICAgICAgLy8tIFJlY3JlYXRlZCBuZXcgc2FsdCBrZXkgdG8gc2hhcmUuXHJcbiAgICAgICAgLy8tIHJlZW5jcnlwdCBrZXkgdmFsdWUgb24gbmV3IHNhbHRcclxuICAgICAgICAvL3VzZXIuLi5yZXZva2VrZXkodG8pO1xyXG4gICAgICAgIGxldCB1c2VyID0gZ3VuLnVzZXIoKTtcclxuICAgICAgICBsZXQgdG8gPSBndW4udXNlcihwdWJsaWNrZXkpO1xyXG4gICAgICAgIHVzZXIuZ2V0KCdwcm9maWxlJykuZ2V0KCdhbGlhcycpLnJldm9rZWtleSh0byk7XHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gcmV2b2tla2V5KHRvLCBjYiwgb3B0KXtcclxuICAgICAgICAvLyByZWNyZWF0ZWQgbmV3IHNhbHQga2V5IHNoYXJlIGN1cnJlbnQgZ3JhcGgga2V5XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJgLnJldm9rZWtleWAgUFJPVE9UWVBFIEFQSSBNQVkgQkUgQ0hBTkdFRCBPUiBSRU5BTUVEIFVTRSFcIik7XHJcbiAgICAgICAgY2IgPSBjYiB8fCBmdW5jdGlvbihjdHgpIHsgcmV0dXJuIGN0eCB9O1xyXG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcclxuICAgICAgICBsZXQgZ3VuID0gdGhpcywgdXNlciA9IGd1bi5iYWNrKC0xKS51c2VyKCksIHBhaXIgPSB1c2VyLl8uc2VhLCBwYXRoID0gJyc7XHJcbiAgICAgICAgZ3VuLmJhY2soZnVuY3Rpb24oYXQpeyBpZihhdC5pcyl7IHJldHVybiB9IHBhdGggKz0gKGF0LmdldHx8JycpIH0pO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2cocGF0aCk7XHJcbiAgICAgICAgaWYoIXRvKXtjb25zb2xlLmxvZyhcInRvIFVzZXIgbm90IHNldCFcIik7fVxyXG4gICAgXHJcbiAgICAgICAgb3B0LnNoYXJla2V5ZGVidWcgPSBvcHQuc2hhcmVrZXlkZWJ1ZyB8fCAgZ3VuLl8ucm9vdC5vcHQuc2hhcmVrZXlkZWJ1ZztcclxuICAgICAgICBvcHQuc2hhcmVrZXl2YWx1ZSA9IG9wdC5zaGFyZWtleXZhbHVlIHx8ICBndW4uXy5yb290Lm9wdC5zaGFyZWtleXZhbHVlO1xyXG4gICAgICAgIG9wdC5zaGFyZWtleXRydXN0ID0gb3B0LnNoYXJla2V5dHJ1c3QgfHwgIGd1bi5fLnJvb3Qub3B0LnNoYXJla2V5dHJ1c3Q7XHJcbiAgICAgICAgb3B0LnNoYXJla2V5YmJhc2UgPSBvcHQuc2hhcmVrZXliYmFzZSB8fCAgZ3VuLl8ucm9vdC5vcHQuc2hhcmVrZXliYmFzZTtcclxuICAgICAgICBpZiAoZ3VuLl8uJCBpbnN0YW5jZW9mIEd1bi5Vc2VyKXsvL2NoZWNrIGd1biBub2RlIGlzIHVzZXIgb2JqZWN0XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJVc2VyIFBBU1NcIik7XHJcbiAgICAgICAgICAgIG9wdC5zaGFyZWtleXR5cGUgPSBcInBhdGhcIjtcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkd1biBQQVNTXCIpO1xyXG4gICAgICAgICAgICBvcHQuc2hhcmVrZXl0eXBlID0gXCJncmFwaFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICAoYXN5bmMgZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgaWYob3B0LnNoYXJla2V5ZGVidWcpe1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJvcHQuc2hhcmVrZXl0eXBlOiBcIixvcHQuc2hhcmVrZXl0eXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgYWxpYXMgPSBhd2FpdCB0by5nZXQoXCJhbGlhc1wiKS50aGVuKCk7XHJcbiAgICAgICAgICAgIGxldCBwdWI7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coYWxpYXMpO1xyXG4gICAgICAgICAgICBpZighYWxpYXMpe1xyXG4gICAgICAgICAgICAgICAgY2Ioe2VycjonRXJyb3IgYWxpYXMgbm90IGZvdW5kISd9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBndW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9HRVQgU2FsdCBLZXlcclxuICAgICAgICAgICAgbGV0IGVuYywgc2VjLCBrZXksIHZhbHVlO1xyXG4gICAgICAgICAgICBpZihvcHQuc2hhcmVrZXl0eXBlID09IFwicGF0aFwiKXtcclxuICAgICAgICAgICAgICAgIHNlYyA9IGF3YWl0IHVzZXIuZ2V0KG9wdC5zaGFyZWtleXRydXN0KS5nZXQocGFpci5wdWIpLmdldChwYXRoKS50aGVuKCk7XHJcbiAgICAgICAgICAgICAgICBpZihvcHQuc2hhcmVrZXlkZWJ1Zyl7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJTRUNSRVQ6IFwiLHNlYyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzZWMgPSBhd2FpdCBTRUEuZGVjcnlwdChzZWMsIHBhaXIpO1xyXG4gICAgICAgICAgICAgICAga2V5ID0gYXdhaXQgZ3VuLm9uY2UoKS50aGVuKCk7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGF3YWl0IFNFQS5kZWNyeXB0KGtleSwgc2VjKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihvcHQuc2hhcmVrZXl0eXBlID09IFwiZ3JhcGhcIil7XHJcbiAgICAgICAgICAgICAgICBzZWMgPSBhd2FpdCBndW4uZ2V0KG9wdC5zaGFyZWtleXRydXN0KS5nZXQocGFpci5wdWIpLmdldChndW4uXy5nZXQpLnRoZW4oKTtcclxuICAgICAgICAgICAgICAgIGlmKG9wdC5zaGFyZWtleWRlYnVnKXtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlNFQ1JFVDogXCIsc2VjKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmKHNlYyAhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKG9wdC5zaGFyZWtleWJiYXNlKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VjID0gd2luZG93LmF0b2Ioc2VjKTsvL2RlY29kZVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzZWMgPSBKU09OLnBhcnNlKHNlYyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzZWMgPSBhd2FpdCBTRUEuZGVjcnlwdChzZWMsIHBhaXIpO1xyXG4gICAgICAgICAgICAgICAga2V5ID0gYXdhaXQgZ3VuLmdldChvcHQuc2hhcmVrZXl2YWx1ZSkub25jZSgpLnRoZW4oKTtcclxuICAgICAgICAgICAgICAgIGlmKG9wdC5zaGFyZWtleWJiYXNlKXtcclxuICAgICAgICAgICAgICAgICAgICBrZXkgPSB3aW5kb3cuYXRvYihrZXkpOy8vZGVjb2RlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBrZXkgPSBKU09OLnBhcnNlKGtleSk7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGF3YWl0IFNFQS5kZWNyeXB0KGtleSwgc2VjKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihvcHQuc2hhcmVrZXlkZWJ1Zyl7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlZBTFVFOiBcIix2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQ3JlYXRlIE5ldyBTYWx0IEtleVxyXG4gICAgICAgICAgICBzZWMgPSBTRUEucmFuZG9tKDE2KS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAvL3NlYyA9IEd1bi50ZXh0LnJhbmRvbSgxNik7XHJcbiAgICAgICAgICAgIGVuYyA9IGF3YWl0IFNFQS5lbmNyeXB0KHNlYywgcGFpcik7XHJcbiAgICAgICAgICAgIGlmKG9wdC5zaGFyZWtleXR5cGUgPT0gXCJwYXRoXCIpe1xyXG4gICAgICAgICAgICAgICAgdXNlci5nZXQob3B0LnNoYXJla2V5dHJ1c3QpLmdldChwYWlyLnB1YikuZ2V0KHBhdGgpLnB1dChlbmMpO1xyXG4gICAgICAgICAgICAgICAgcHViID0gYXdhaXQgdG8uZ2V0KCdwdWInKS50aGVuKCk7Ly9yZXZva2UgdXNlclxyXG4gICAgICAgICAgICAgICAgdXNlci5nZXQob3B0LnNoYXJla2V5dHJ1c3QpLm9uY2UoKS5tYXAoKS5vbmNlKGFzeW5jIChkYXRhLG1rZXkpPT57Ly90cnVzdCB1c2Vyc1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB1bmFtZTtcclxuICAgICAgICAgICAgICAgICAgICBpZihvcHQuc2hhcmVrZXlkZWJ1Zyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuYW1lID0gYXdhaXQgZ3VuLmJhY2soLTEpLnVzZXIobWtleSkuZ2V0KCdhbGlhcycpLnRoZW4oKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYocGFpci5wdWIgIT0gbWtleSl7Ly9jaGVjayBzZWxmIHVzZXIgdG8gYmUgcmVzYWx0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHB1YiA9PSBta2V5KXsgLy9jaGVjayB1c2VyIHRvIGJlIHJldm9rZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9kbyBub3RoaW5nPz8/IChyZXZva2UgdXNlcilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKG9wdC5zaGFyZWtleWRlYnVnKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyh1bmFtZSwgXCJGQUlMXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBja2V5ID0gYXdhaXQgdXNlci5nZXQob3B0LnNoYXJla2V5dHJ1c3QpLmdldChta2V5KS5nZXQocGF0aCkudGhlbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYob3B0LnNoYXJla2V5ZGVidWcpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHVuYW1lLCBcIlBBU1NcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihja2V5ICE9IFwibnVsbFwiKXsvL0NoZWNrIGlmIHRoZXJlIHVzZXIgYXJlIHJldm9rZSBrZXkgaWYgdGhleSBhcmUgbnVsbCBzaG91bGQgYmUgaWdub3JlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKG9wdC5zaGFyZWtleWRlYnVnKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2codW5hbWUsIFwiQ1JFQVRFIE5FVyBTQUxUIFNIQVJFIEtFWSBcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtdG8gPSBndW4uYmFjaygtMSkudXNlcihta2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbXB1YiA9IGF3YWl0IG10by5nZXQoJ3B1YicpLnRoZW4oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWVwdWIgPSBhd2FpdCBtdG8uZ2V0KCdlcHViJykudGhlbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkaCA9IGF3YWl0IFNFQS5zZWNyZXQobWVwdWIsIHBhaXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtZW5jID0gYXdhaXQgU0VBLmVuY3J5cHQoc2VjLCBkaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9ORVcgU0FMVCBLRVlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihvcHQuc2hhcmVrZXlkZWJ1Zyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTkVXIFNIQVJFIEtFWTogXCIsbWVuYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXIuZ2V0KG9wdC5zaGFyZWtleXRydXN0KS5nZXQobXB1YikuZ2V0KHBhdGgpLnB1dChtZW5jKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKG9wdC5zaGFyZWtleXR5cGUgPT0gXCJncmFwaFwiKXtcclxuICAgICAgICAgICAgICAgIGVuYyA9IEpTT04uc3RyaW5naWZ5KGVuYyk7Ly9uZWVkIHRvIGJlIHN0cmluZyBidWcgcm9vdCBndW5cclxuICAgICAgICAgICAgICAgIGVuYyA9IHdpbmRvdy5idG9hKGVuYyk7XHJcbiAgICAgICAgICAgICAgICBndW4uZ2V0KG9wdC5zaGFyZWtleXRydXN0KS5nZXQocGFpci5wdWIpLmdldChndW4uXy5nZXQpLnB1dChlbmMpO1xyXG4gICAgICAgICAgICAgICAgcHViID0gYXdhaXQgdG8uZ2V0KCdwdWInKS50aGVuKCk7XHJcbiAgICBcclxuICAgICAgICAgICAgICAgIGd1bi5nZXQob3B0LnNoYXJla2V5dHJ1c3QpLm1hcCgpLm9uY2UoYXN5bmMgKGRhdGEsbWtleSk9PnsvL3RydXN0IHVzZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHVuYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKG9wdC5zaGFyZWtleWRlYnVnKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdW5hbWUgPSBhd2FpdCBndW4uYmFjaygtMSkudXNlcihta2V5KS5nZXQoJ2FsaWFzJykudGhlbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZihwYWlyLnB1YiAhPSBta2V5KXsvL2NoZWNrIHNlbGYgdXNlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihwdWIgPT0gbWtleSl7IC8vY2hlY2sgdXNlciB0byBiZSByZXZva2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZG8gbm90IGhlcmU/KGJhbiB1c2VyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYob3B0LnNoYXJla2V5ZGVidWcpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHVuYW1lLCBcIkZBSUxcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNrZXkgPSBhd2FpdCBndW4uZ2V0KG9wdC5zaGFyZWtleXRydXN0KS5nZXQoa2V5KS5nZXQoZ3VuLl8uZ2V0KS50aGVuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihvcHQuc2hhcmVrZXlkZWJ1Zyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2codW5hbWUsIFwiUEFTU1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNrZXkgIT0gXCJudWxsXCIpey8vQ2hlY2sgaWYgdGhlcmUgdXNlciBhcmUgcmV2b2tlIGtleSBpZiB0aGV5IGFyZSBudWxsLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKG9wdC5zaGFyZWtleWRlYnVnKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2codW5hbWUsIFwiTkVXIFNIQVJFIEtFWSFcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtdG8gPSBndW4uYmFjaygtMSkudXNlcihta2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbXB1YiA9IGF3YWl0IG10by5nZXQoJ3B1YicpLnRoZW4oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWVwdWIgPSBhd2FpdCBtdG8uZ2V0KCdlcHViJykudGhlbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkaCA9IGF3YWl0IFNFQS5zZWNyZXQobWVwdWIsIHBhaXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vTkVXIFNIQVJFIEtFWVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtZW5jID0gYXdhaXQgU0VBLmVuY3J5cHQoc2VjLCBkaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVuYyA9IEpTT04uc3RyaW5naWZ5KG1lbmMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKG9wdC5zaGFyZWtleWJiYXNlKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVuYyA9IHdpbmRvdy5idG9hKG1lbmMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihvcHQuc2hhcmVrZXlkZWJ1Zyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTkVXIFNIQVJFIEtFWTogXCIsbWVuYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGd1bi5nZXQob3B0LnNoYXJla2V5dHJ1c3QpLmdldChtcHViKS5nZXQoZ3VuLl8uZ2V0KS5wdXQobWVuYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vZW5jcnlwdCBWYWx1ZVxyXG4gICAgICAgICAgICBsZXQgdiA9IGF3YWl0IFNFQS5lbmNyeXB0KHZhbHVlLCBzZWMpO1xyXG4gICAgICAgICAgICBpZihvcHQuc2hhcmVrZXl0eXBlID09IFwicGF0aFwiKXtcclxuICAgICAgICAgICAgICAgIGd1bi5wdXQodiwgY2IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKG9wdC5zaGFyZWtleXR5cGUgPT0gXCJncmFwaFwiKXtcclxuICAgICAgICAgICAgICAgIHYgPSBKU09OLnN0cmluZ2lmeSh2KTtcclxuICAgICAgICAgICAgICAgIGlmKG9wdC5zaGFyZWtleWJiYXNlKXtcclxuICAgICAgICAgICAgICAgICAgICB2ID0gd2luZG93LmJ0b2Eodik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBndW4uZ2V0KG9wdC5zaGFyZWtleXZhbHVlKS5wdXQodiwgY2IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFJFTU9WRSBTSEFSRSBLRVlcclxuICAgICAgICAgICAgcHViID0gYXdhaXQgdG8uZ2V0KCdwdWInKS50aGVuKCk7XHJcbiAgICAgICAgICAgIGlmKG9wdC5zaGFyZWtleXR5cGUgPT0gXCJwYXRoXCIpe1xyXG4gICAgICAgICAgICAgICAgdXNlci5nZXQob3B0LnNoYXJla2V5dHJ1c3QpLmdldChwdWIpLmdldChwYXRoKS5wdXQoXCJudWxsXCIsIGNiKTsvL1JFTU9WRSBTRUNSRVQgS0VZXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYob3B0LnNoYXJla2V5dHlwZSA9PSBcImdyYXBoXCIpe1xyXG4gICAgICAgICAgICAgICAgZ3VuLmdldChvcHQuc2hhcmVrZXl0cnVzdCkuZ2V0KHB1YikuZ2V0KGd1bi5fLmdldCkucHV0KFwibnVsbFwiLCBjYik7Ly9SRU1PVkUgU0VDUkVUIEtFWVxyXG4gICAgICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIHJldHVybiBndW47XHJcbiAgICB9XHJcbiAgICAvKlxyXG4gICAgICAgIC8vdXNlci4uLmVuY3J5cHRwdXQodmFsdWUpO1xyXG4gICAgICAgIGxldCB1c2VyID0gZ3VuLnVzZXIoKTtcclxuICAgICAgICB1c2VyLmdldCgncHJvZmlsZScpLmdldCgnYWxpYXMnKS5lbmNyeXB0cHV0KFwibmFtZVwiKTtcclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBlbmNyeXB0cHV0KGRhdGEsIGNiLCBvcHQpe1xyXG4gICAgICAgIC8vIGVuY3J5cHQga2V5ID4gcHV0IHZhbHVlXHJcbiAgICAgICAgY29uc29sZS5sb2coXCJgLmVuY3J5cHRwdXRgIFBST1RPVFlQRSBBUEkgTUFZIEJFIENIQU5HRUQgT1IgUkVOQU1FRCBVU0UhXCIpO1xyXG4gICAgICAgIGNiID0gY2IgfHwgZnVuY3Rpb24oY3R4KSB7IHJldHVybiBjdHggfTtcclxuICAgICAgICBvcHQgPSBvcHQgfHwge307XHJcbiAgICAgICAgbGV0IGd1biA9IHRoaXMsIHVzZXIgPSBndW4uYmFjaygtMSkudXNlcigpLCBwYWlyID0gdXNlci5fLnNlYSwgcGF0aCA9ICcnO1xyXG4gICAgICAgIGxldCByb290Z3VuID0gdGhpcztcclxuICAgICAgICBndW4uYmFjayhmdW5jdGlvbihhdCl7IGlmKGF0LmlzKXsgcmV0dXJuIH0gcGF0aCArPSAoYXQuZ2V0fHwnJykgfSk7XHJcblxyXG4gICAgICAgIG9wdC5zaGFyZWtleWRlYnVnID0gb3B0LnNoYXJla2V5ZGVidWcgfHwgIGd1bi5fLnJvb3Qub3B0LnNoYXJla2V5ZGVidWc7XHJcbiAgICAgICAgb3B0LnNoYXJla2V5dmFsdWUgPSBvcHQuc2hhcmVrZXl2YWx1ZSB8fCAgZ3VuLl8ucm9vdC5vcHQuc2hhcmVrZXl2YWx1ZTtcclxuICAgICAgICBvcHQuc2hhcmVrZXl0cnVzdCA9IG9wdC5zaGFyZWtleXRydXN0IHx8ICBndW4uXy5yb290Lm9wdC5zaGFyZWtleXRydXN0O1xyXG4gICAgICAgIG9wdC5zaGFyZWtleWJiYXNlID0gb3B0LnNoYXJla2V5YmJhc2UgfHwgIGd1bi5fLnJvb3Qub3B0LnNoYXJla2V5YmJhc2U7XHJcbiAgICAgICAgaWYgKGd1bi5fLiQgaW5zdGFuY2VvZiBHdW4uVXNlcil7Ly9jaGVjayBndW4gbm9kZSBpcyB1c2VyIG9iamVjdFxyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiVXNlciBQQVNTXCIpO1xyXG4gICAgICAgICAgICBvcHQuc2hhcmVrZXl0eXBlID0gXCJwYXRoXCI7XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJHdW4gUEFTU1wiKTtcclxuICAgICAgICAgICAgb3B0LnNoYXJla2V5dHlwZSA9IFwiZ3JhcGhcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhHdW4uaXMoZ3VuKSk7Ly9jaGVjayBpZiBndW4gaXMgb2JqZWN0IG1hdGNoXHJcblxyXG4gICAgICAgIChhc3luYyBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICBpZihvcHQuc2hhcmVrZXlkZWJ1Zyl7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIm9wdC5zaGFyZWtleXR5cGU6IFwiLG9wdC5zaGFyZWtleXR5cGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBlbmMsIHNlYztcclxuICAgICAgICAgICAgaWYob3B0LnNoYXJla2V5dHlwZSA9PSBcInBhdGhcIil7XHJcbiAgICAgICAgICAgICAgICBzZWMgPSBhd2FpdCB1c2VyLmdldChvcHQuc2hhcmVrZXl0cnVzdCkuZ2V0KHBhaXIucHViKS5nZXQocGF0aCkudGhlbigpO1xyXG4gICAgICAgICAgICAgICAgaWYob3B0LnNoYXJla2V5ZGVidWcpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU0VDUkVUOiBcIixzZWMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2VjID0gYXdhaXQgU0VBLmRlY3J5cHQoc2VjLCBwYWlyKTtcclxuICAgICAgICAgICAgICAgIGlmKCFzZWMpe1xyXG4gICAgICAgICAgICAgICAgICAgIHNlYyA9IFNFQS5yYW5kb20oMTYpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYob3B0LnNoYXJla2V5ZGVidWcpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkNSRUFURSBTRUNSRVQ6IFwiLHNlYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vc2VjID0gR3VuLnRleHQucmFuZG9tKDE2KTtcclxuICAgICAgICAgICAgICAgICAgICBlbmMgPSBhd2FpdCBTRUEuZW5jcnlwdChzZWMsIHBhaXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHVzZXIuZ2V0KG9wdC5zaGFyZWtleXRydXN0KS5nZXQocGFpci5wdWIpLmdldChwYXRoKS5wdXQoZW5jKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVuYyA9IGF3YWl0IFNFQS5lbmNyeXB0KGRhdGEsIHNlYyk7XHJcbiAgICAgICAgICAgICAgICBndW4ucHV0KGVuYywgY2IpOy8vUFVUIEVOQ1JZUFQgREFUQVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZihvcHQuc2hhcmVrZXl0eXBlID09IFwiZ3JhcGhcIil7XHJcbiAgICAgICAgICAgICAgICBzZWMgPSBhd2FpdCBndW4uZ2V0KG9wdC5zaGFyZWtleXRydXN0KS5nZXQocGFpci5wdWIpLmdldChndW4uXy5nZXQpLnRoZW4oKTtcclxuICAgICAgICAgICAgICAgIGlmKG9wdC5zaGFyZWtleWRlYnVnKXtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlNFQ1JFVDogXCIsc2VjKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmKHNlYyAhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKG9wdC5zaGFyZWtleWJiYXNlKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VjID0gd2luZG93LmF0b2Ioc2VjKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc2VjID0gSlNPTi5wYXJzZShzZWMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlYyA9IGF3YWl0IFNFQS5kZWNyeXB0KHNlYywgcGFpcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZighc2VjKXtcclxuICAgICAgICAgICAgICAgICAgICBzZWMgPSBTRUEucmFuZG9tKDE2KS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKG9wdC5zaGFyZWtleWRlYnVnKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJDUkVBVEUgU0VDUkVUOiBcIixzZWMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbmMgPSBhd2FpdCBTRUEuZW5jcnlwdChzZWMsIHBhaXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVuYyA9IEpTT04uc3RyaW5naWZ5KGVuYyk7Ly9uZWVkIHRvIGJlIHN0cmluZyBidWcgcm9vdCBndW5cclxuICAgICAgICAgICAgICAgICAgICBpZihvcHQuc2hhcmVrZXliYmFzZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuYyA9IHdpbmRvdy5idG9hKGVuYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKG9wdC5zaGFyZWtleWRlYnVnKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJTRUNSRVQgRU5DOiBcIixlbmMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBndW4uZ2V0KG9wdC5zaGFyZWtleXRydXN0KS5nZXQocGFpci5wdWIpLmdldChndW4uXy5nZXQpLnB1dChlbmMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYob3B0LnNoYXJla2V5ZGVidWcpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiREFUQTogXCIsZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbmMgPSBhd2FpdCBTRUEuZW5jcnlwdChkYXRhLCBzZWMpO1xyXG4gICAgICAgICAgICAgICAgZW5jID0gSlNPTi5zdHJpbmdpZnkoZW5jKTtcclxuICAgICAgICAgICAgICAgIGlmKG9wdC5zaGFyZWtleWJiYXNlKXtcclxuICAgICAgICAgICAgICAgICAgICBlbmMgPSB3aW5kb3cuYnRvYShlbmMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy9ndW4gcHV0IG5lZWQgYmUgY2hpbGQga2V5IHZhbHVlXHJcbiAgICAgICAgICAgICAgICBndW4uZ2V0KG9wdC5zaGFyZWtleXZhbHVlKS5wdXQoZW5jLCBjYik7Ly9QVVQgRU5DUllQVCBEQVRBXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIHJldHVybiBndW47XHJcbiAgICB9XHJcbiAgICAvKlxyXG4gICAgICAgIHVzZXIuLi5kZWNyeXB0dmFsdWUoY2IpO1xyXG4gICAgICAgIGxldCB1c2VyID0gZ3VuLnVzZXIoKTtcclxuICAgICAgICB1c2VyLmdldCgncHJvZmlsZScpLmdldCgnYWxpYXMnKS5kZWNyeXB0dmFsdWUoYWNrPT57XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coYWNrKTtcclxuICAgICAgICB9KTtcclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBkZWNyeXB0dmFsdWUoY2Isb3B0KXtcclxuICAgICAgICAvL2dldCBkZWNyeXB0IGtleSB0byByZXR1cm4gdmFsdWVcclxuICAgICAgICBjb25zb2xlLmxvZyhcImAuZGVjcnlwdHZhbHVlYCBQUk9UT1RZUEUgQVBJIE1BWSBCRSBDSEFOR0VEIE9SIFJFTkFNRUQgVVNFIVwiKTtcclxuICAgICAgICBjYiA9IGNiIHx8IGZ1bmN0aW9uKGN0eCkgeyByZXR1cm4gY3R4IH07XHJcbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xyXG4gICAgICAgIGxldCBndW4gPSB0aGlzLCB1c2VyID0gZ3VuLmJhY2soLTEpLnVzZXIoKSwgcGFpciA9IHVzZXIuXy5zZWEsIHBhdGggPSAnJztcclxuICAgIFxyXG4gICAgICAgIG9wdC5zaGFyZWtleWRlYnVnID0gb3B0LnNoYXJla2V5ZGVidWcgfHwgIGd1bi5fLnJvb3Qub3B0LnNoYXJla2V5ZGVidWc7XHJcbiAgICAgICAgb3B0LnNoYXJla2V5dmFsdWUgPSBvcHQuc2hhcmVrZXl2YWx1ZSB8fCAgZ3VuLl8ucm9vdC5vcHQuc2hhcmVrZXl2YWx1ZTtcclxuICAgICAgICBvcHQuc2hhcmVrZXl0cnVzdCA9IG9wdC5zaGFyZWtleXRydXN0IHx8ICBndW4uXy5yb290Lm9wdC5zaGFyZWtleXRydXN0O1xyXG4gICAgICAgIG9wdC5zaGFyZWtleWJiYXNlID0gb3B0LnNoYXJla2V5YmJhc2UgfHwgIGd1bi5fLnJvb3Qub3B0LnNoYXJla2V5YmJhc2U7XHJcbiAgICBcclxuICAgICAgICBndW4uYmFjayhmdW5jdGlvbihhdCl7IGlmKGF0LmlzKXsgcmV0dXJuIH0gcGF0aCArPSAoYXQuZ2V0fHwnJykgfSk7XHJcblxyXG4gICAgICAgIGlmIChndW4uXy4kIGluc3RhbmNlb2YgR3VuLlVzZXIpey8vY2hlY2sgZ3VuIG5vZGUgaXMgdXNlciBvYmplY3RcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlVzZXIgUEFTU1wiKTtcclxuICAgICAgICAgICAgb3B0LnNoYXJla2V5dHlwZSA9IFwicGF0aFwiO1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiR3VuIFBBU1NcIik7XHJcbiAgICAgICAgICAgIG9wdC5zaGFyZWtleXR5cGUgPSBcImdyYXBoXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIChhc3luYyBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICBpZihvcHQuc2hhcmVrZXlkZWJ1Zyl7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIm9wdC5zaGFyZWtleXR5cGU6IFwiLG9wdC5zaGFyZWtleXR5cGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBzZWMsIGtleTtcclxuICAgICAgICAgICAgaWYob3B0LnNoYXJla2V5dHlwZSA9PSBcInBhdGhcIil7XHJcbiAgICAgICAgICAgICAgICBzZWMgPSBhd2FpdCB1c2VyLmdldChvcHQuc2hhcmVrZXl0cnVzdCkuZ2V0KHBhaXIucHViKS5nZXQocGF0aCkudGhlbigpO1xyXG4gICAgICAgICAgICAgICAgaWYob3B0LnNoYXJla2V5ZGVidWcpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU0VDUkVUOiBcIixzZWMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYoIXNlYyl7XHJcbiAgICAgICAgICAgICAgICAgICAgY2IobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGd1bjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNlYyA9IGF3YWl0IFNFQS5kZWNyeXB0KHNlYywgcGFpcik7XHJcbiAgICAgICAgICAgICAgICBrZXkgPSBhd2FpdCBndW4udGhlbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKG9wdC5zaGFyZWtleXR5cGUgPT0gXCJncmFwaFwiKXtcclxuICAgICAgICAgICAgICAgIHNlYyA9IGF3YWl0IGd1bi5nZXQob3B0LnNoYXJla2V5dHJ1c3QpLmdldChwYWlyLnB1YikuZ2V0KGd1bi5fLmdldCkudGhlbigpO1xyXG4gICAgICAgICAgICAgICAgaWYob3B0LnNoYXJla2V5ZGVidWcpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU0VDUkVUOiBcIixzZWMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYoIXNlYyl7XHJcbiAgICAgICAgICAgICAgICAgICAgY2IobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGd1bjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmKG9wdC5zaGFyZWtleWJiYXNlKXtcclxuICAgICAgICAgICAgICAgICAgICBzZWMgPSB3aW5kb3cuYXRvYihzZWMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2VjID0gSlNPTi5wYXJzZShzZWMpO1xyXG4gICAgICAgICAgICAgICAgc2VjID0gYXdhaXQgU0VBLmRlY3J5cHQoc2VjLCBwYWlyKTtcclxuICAgICAgICAgICAgICAgIGtleSA9IGF3YWl0IGd1bi5nZXQob3B0LnNoYXJla2V5dmFsdWUpLnRoZW4oKTsvL2RlZmF1bHQgJ3ZhbHVlJ1xyXG4gICAgICAgICAgICAgICAgaWYob3B0LnNoYXJla2V5ZGVidWcpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVkFMVUUgU0VDOiBcIixrZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYoa2V5ICE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYob3B0LnNoYXJla2V5YmJhc2Upe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSB3aW5kb3cuYXRvYihrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBrZXkgPSBKU09OLnBhcnNlKGtleSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IG12YWx1ZSA9IGF3YWl0IFNFQS5kZWNyeXB0KGtleSwgc2VjKTtcclxuICAgICAgICAgICAgaWYob3B0LnNoYXJla2V5ZGVidWcpe1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJWQUxVRTogXCIsIG12YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2IobXZhbHVlKTtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIHJldHVybiBndW47XHJcbiAgICB9XHJcbiAgICAvL3dvcmtpbmcgdG8gZGVjcnlwdCBkYXRhPz9cclxuICAgIC8qXHJcbiAgICAgICAgLy91c2VyLi4uZGVjcnlwdGRhdGEodG8sZGIpO1xyXG4gICAgICAgIC8vZ3VuLi4uZGVjcnlwdGRhdGEodG8sZGIpO1xyXG4gICAgICAgIGxldCB1c2VyID0gZ3VuLnVzZXIoKTtcclxuICAgICAgICBsZXQgdG8gPSBndW4udXNlcihwdWJsaWNrZXkpO1xyXG4gICAgICAgIHRvLmdldChcInByb2ZpbGVcIikuZ2V0KFwiYWxpYXNcIikuZGVjcnlwdGRhdGEodG8sYWNrPT57XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGFjayk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gZGVjcnlwdGRhdGEodG8sIGNiLCBvcHQpe1xyXG4gICAgICAgIC8vIGd1biBncmFwaCB0byBkZWNyeXB0IGtleSB0byByZXR1cm4gdmFsdWVcclxuICAgICAgICBjb25zb2xlLmxvZyhcImAuZGVjcnlwdGRhdGFgIFBST1RPVFlQRSBBUEkgTUFZIEJFIERFTEVURUQgT1IgQ0hBTkdFRCBPUiBSRU5BTUVEIFVTRSFcIik7XHJcbiAgICAgICAgY2IgPSBjYiB8fCBmdW5jdGlvbihjdHgpIHsgcmV0dXJuIGN0eCB9O1xyXG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcclxuICAgICAgICBsZXQgZ3VuID0gdGhpcywgdXNlciA9IGd1bi5iYWNrKC0xKS51c2VyKCksIHBhaXIgPSB1c2VyLl8uc2VhLCBwYXRoID0gJyc7XHJcbiAgICAgICAgLy9vcHQuc2hhcmVrZXl0eXBlID0gb3B0LnNoYXJla2V5dHlwZSB8fCBndW4uXy5yb290Lm9wdC5zaGFyZWtleXR5cGU7XHJcbiAgICAgICAgb3B0LnNoYXJla2V5ZGVidWcgPSBvcHQuc2hhcmVrZXlkZWJ1ZyB8fCAgZ3VuLl8ucm9vdC5vcHQuc2hhcmVrZXlkZWJ1ZztcclxuICAgICAgICBvcHQuc2hhcmVrZXl2YWx1ZSA9IG9wdC5zaGFyZWtleXZhbHVlIHx8ICBndW4uXy5yb290Lm9wdC5zaGFyZWtleXZhbHVlO1xyXG4gICAgICAgIG9wdC5zaGFyZWtleXRydXN0ID0gb3B0LnNoYXJla2V5dHJ1c3QgfHwgIGd1bi5fLnJvb3Qub3B0LnNoYXJla2V5dHJ1c3Q7XHJcbiAgICAgICAgb3B0LnNoYXJla2V5YmJhc2UgPSBvcHQuc2hhcmVrZXliYmFzZSB8fCAgZ3VuLl8ucm9vdC5vcHQuc2hhcmVrZXliYmFzZTtcclxuICAgICAgICBpZighdG8pe1xyXG4gICAgICAgICAgICBjYih7ZXJyOlwiVXNlciBub3Qgc2V0IVwifSk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVXNlciBncmFwaCBuZXQgc2V0IVwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIGd1bjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc29sZS5sb2cob3B0LnNoYXJla2V5ZGVidWcpO1xyXG5cclxuICAgICAgICBpZiAoZ3VuLl8uJCBpbnN0YW5jZW9mIEd1bi5Vc2VyKXsvL2NoZWNrIGd1biBub2RlIGlzIHVzZXIgb2JqZWN0XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJVc2VyIFBBU1NcIik7XHJcbiAgICAgICAgICAgIG9wdC5zaGFyZWtleXR5cGUgPSBvcHQuc2hhcmVrZXl0eXBlIHx8IFwicGF0aFwiO1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiR3VuIFBBU1NcIik7XHJcbiAgICAgICAgICAgIG9wdC5zaGFyZWtleXR5cGUgPSBvcHQuc2hhcmVrZXl0eXBlIHx8IFwiZ3JhcGhcIjtcclxuICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICBndW4uYmFjayhmdW5jdGlvbihhdCl7IGlmKGF0LmlzKXsgcmV0dXJuIH0gcGF0aCArPSAoYXQuZ2V0fHwnJykgfSk7XHJcbiAgICAgICAgKGFzeW5jIGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIGlmKG9wdC5zaGFyZWtleWRlYnVnKXtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwib3B0LnNoYXJla2V5dHlwZTogXCIsb3B0LnNoYXJla2V5dHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9LRVkgU0FMVFxyXG4gICAgICAgICAgICBsZXQgZW5jMVxyXG4gICAgICAgICAgICBpZihvcHQuc2hhcmVrZXl0eXBlID09IFwicGF0aFwiKXtcclxuICAgICAgICAgICAgICAgIGVuYzEgPSBhd2FpdCB0by5nZXQoJ3RydXN0JykuZ2V0KHBhaXIucHViKS5nZXQocGF0aCkudGhlbigpO1xyXG4gICAgICAgICAgICAgICAgaWYob3B0LnNoYXJla2V5ZGVidWcpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU0VDUkVUOiBcIixlbmMxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihvcHQuc2hhcmVrZXl0eXBlID09IFwiZ3JhcGhcIil7XHJcbiAgICAgICAgICAgICAgICBlbmMxID0gYXdhaXQgZ3VuLmdldCgndHJ1c3QnKS5nZXQocGFpci5wdWIpLmdldChndW4uXy5nZXQpLnRoZW4oKTtcclxuICAgICAgICAgICAgICAgIGlmKG9wdC5zaGFyZWtleWRlYnVnKXtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlNFQ1JFVDogXCIsZW5jMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZihlbmMxICE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoZW5jMSA9PSBcIm51bGxcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRXJyb3IgTnVsbCB8fCBEZW5pZWQhXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYihudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGd1bjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYob3B0LnNoYXJla2V5YmJhc2Upe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmMxID0gd2luZG93LmF0b2IoZW5jMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVuYzEgPSBKU09OLnBhcnNlKGVuYzEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKCFlbmMxKXtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRXJyb3IgTnVsbCB8fCBEZW5pZWQhXCIpO1xyXG4gICAgICAgICAgICAgICAgY2IobnVsbCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZ3VuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBlcHViID0gYXdhaXQgdG8uZ2V0KCdlcHViJykudGhlbigpO1xyXG4gICAgICAgICAgICAvL1BBSVIgU0hBUkVcclxuICAgICAgICAgICAgbGV0IG1peCA9IGF3YWl0IFNFQS5zZWNyZXQoZXB1YiwgcGFpcik7XHJcbiAgICAgICAgICAgIC8vS0VZIFNIQVJFXHJcbiAgICAgICAgICAgIGxldCBrZXkgPSBhd2FpdCBTRUEuZGVjcnlwdChlbmMxLCBtaXgpO1xyXG4gICAgICAgICAgICBpZihvcHQuc2hhcmVrZXlkZWJ1Zyl7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImtleTogXCIsa2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL1ZBTFVFXHJcbiAgICAgICAgICAgIGxldCBlbmMyIFxyXG4gICAgICAgICAgICBpZihvcHQuc2hhcmVrZXl0eXBlID09IFwicGF0aFwiKXtcclxuICAgICAgICAgICAgICAgIGVuYzIgPSBhd2FpdCBndW4udGhlbigpO1xyXG4gICAgICAgICAgICAgICAgaWYob3B0LnNoYXJla2V5ZGVidWcpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVkFMVUUgc2VjOiBcIixlbmMyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihvcHQuc2hhcmVrZXl0eXBlID09IFwiZ3JhcGhcIil7XHJcbiAgICAgICAgICAgICAgICBlbmMyID0gYXdhaXQgZ3VuLmdldChvcHQuc2hhcmVrZXl2YWx1ZSkudGhlbigpO1xyXG4gICAgICAgICAgICAgICAgaWYob3B0LnNoYXJla2V5ZGVidWcpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVkFMVUUgc2VjOiBcIixlbmMyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmKG9wdC5zaGFyZWtleWJiYXNlKXtcclxuICAgICAgICAgICAgICAgICAgICBlbmMyID0gd2luZG93LmF0b2IoZW5jMik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbmMyID0gSlNPTi5wYXJzZShlbmMyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgZHZhbHVlID0gYXdhaXQgU0VBLmRlY3J5cHQoZW5jMiwga2V5KTtcclxuICAgICAgICAgICAgaWYob3B0LnNoYXJla2V5ZGVidWcpe1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJWQUxVRTogXCIsZHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYihkdmFsdWUpO1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgcmV0dXJuIGd1bjtcclxuICAgIH1cclxuICAgIC8vU0VUVVAgRlVOQ1RJT04gZm9yIEdVTlxyXG4gICAgR3VuLmNoYWluLmdyYW50a2V5ID0gZ3JhbnRrZXk7XHJcbiAgICBHdW4uY2hhaW4ucmV2b2tla2V5ID0gcmV2b2tla2V5O1xyXG4gICAgR3VuLmNoYWluLmVuY3J5cHRwdXQgPSBlbmNyeXB0cHV0O1xyXG4gICAgR3VuLmNoYWluLmRlY3J5cHR2YWx1ZSA9IGRlY3J5cHR2YWx1ZTtcclxuICAgIEd1bi5jaGFpbi5kZWNyeXB0ZGF0YSA9IGRlY3J5cHRkYXRhO1xyXG4gICAgXHJcbn0oKSk7Il19